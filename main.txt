package main

import (
	// Imports from main.txt
	"encoding/json"
	"log"
	"math/rand" // Для генерации случайных чисел
	"net/http"
	"sync"
	"time" // Для таймеров и времени

	"metrics-visualizer/internal/model" // Импорт вашего пакета model
	"github.com/gorilla/websocket"      // Библиотека для WebSocket

	// Imports from main1.txt
	"context"
	"fmt" // Used in main1.txt's original main for printing startup message

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
)

// --- Structs ---

// ServerState - структура для хранения состояния каждого сервера (из main.txt)
type ServerState struct {
	Uptime int
}

// --- Global Variables ---

var (
	// Variables from main.txt (WebSocket Metrics)
	clients = make(map[*websocket.Conn]bool)
	broadcast = make(chan model.ServerMetrics)
	mutex = &sync.Mutex{}
	serversState = make(map[string]*ServerState)
	stateMutex   = &sync.Mutex{}
	upgrader = websocket.Upgrader{
		CheckOrigin: func(r *http.Request) bool {
			return true // Allow all origins for simplicity
		},
	}

	// Variables from main1.txt (Google OAuth2)
	// !!! ВАЖНО: Замените YOUR_CLIENT_ID и YOUR_CLIENT_SECRET вашими реальными значениями !!!
	oauthConf = &oauth2.Config{
		ClientID:     "975025326030-bbq0pt2be979pq5748alk3ji8fmbqf0a.apps.googleusercontent.com",     // <--- ЗАМЕНИТЕ ЭТО
		go  "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", // <--- ЗАМЕНИТЕ ЭТО
		RedirectURL:  "http://localhost:8080/callback", // Убедитесь, что это совпадает с настройками Google Cloud Console
		Scopes:       []string{"openid", "email", "profile"},
		Endpoint:     google.Endpoint,
	}
)

// --- WebSocket Metrics Functions (from main.txt) ---

// handleConnections - обработчик WebSocket подключений
func handleConnections(w http.ResponseWriter, r *http.Request) {
	ws, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("Ошибка при апгрейде до WebSocket: %v", err)
		http.Error(w, "Could not open websocket connection", http.StatusInternalServerError)
		return
	}
	defer ws.Close()

	mutex.Lock()
	clients[ws] = true
	mutex.Unlock()
	log.Printf("Новый WebSocket клиент подключился: %s. Всего клиентов: %d", r.RemoteAddr, len(clients))

	for {
		_, _, err := ws.ReadMessage()
		if err != nil {
			log.Printf("WebSocket клиент отключился (ошибка чтения): %s, %v", r.RemoteAddr, err)
			mutex.Lock()
			delete(clients, ws)
			mutex.Unlock()
			break
		}
		// Игнорируем сообщения от клиента в этой версии
	}
}

// handleMessages - горутина для рассылки метрик клиентам
func handleMessages() {
	for {
		metric := <-broadcast
		jsonMetric, err := json.Marshal(metric)
		if err != nil {
			log.Printf("Ошибка при преобразовании метрики в JSON: %v", err)
			continue
		}

		mutex.Lock()
		// Копируем ключи (клиентов) для безопасной итерации и удаления
		clientsToRemove := []*websocket.Conn{}
		for client := range clients {
			err := client.WriteMessage(websocket.TextMessage, jsonMetric)
			if err != nil {
				log.Printf("Ошибка при отправке метрики клиенту %s: %v. Удаление клиента.", client.RemoteAddr(), err)
				client.Close()
				clientsToRemove = append(clientsToRemove, client)
			}
		}
		// Удаляем клиентов с ошибками вне основного цикла итерации
		for _, client := range clientsToRemove {
			delete(clients, client)
		}
		mutex.Unlock()
	}
}

// generateMetricsForServer - горутина для генерации метрик одного сервера
func generateMetricsForServer(hostname string, metricChan chan<- model.ServerMetrics) {
	stateMutex.Lock()
	state, ok := serversState[hostname]
	if !ok {
		state = &ServerState{Uptime: 0}
		serversState[hostname] = state
		log.Printf("Инициализировано состояние для сервера: %s", hostname)
	}
	stateMutex.Unlock()

	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	for range ticker.C {
		// Генерируем случайные значения для метрик
		cpuUsage := rand.Float64() * 100
		memoryUsage := rand.Float64() * 100
		diskIO := rand.Float64() * 500
		networkIn := rand.Float64() * 200
		networkOut := rand.Float64() * 200

		// Генерируем всю структуру метрики здесь
		// (Как обсуждалось, если у вас есть `generator.generateMetric`, адаптируйте вызов)
		stateMutex.Lock() // Защищаем доступ к state.Uptime
		metric := model.ServerMetrics{
			Timestamp:   time.Now().Unix(),
			CPUUsage:    cpuUsage,
			MemoryUsage: memoryUsage,
			DiskIO:      diskIO,
			NetworkIn:   networkIn,
			NetworkOut:  networkOut,
			Uptime:      int64(state.Uptime),
			Hostname:    hostname,
		}
		state.Uptime++
		stateMutex.Unlock() // Освобождаем мьютекс после обновления

		metricChan <- metric
	}
}

// --- Google OAuth2 Functions (from main1.txt) ---

// handleAuth - обработчик для начала процесса аутентификации
func handleAuth(w http.ResponseWriter, r *http.Request) {
	// Генерируем state для защиты от CSRF, можно использовать более надежный метод
	// В этом примере используется статичный "state-token"
	url := oauthConf.AuthCodeURL("state-token", oauth2.AccessTypeOffline)
	log.Printf("Перенаправление на URL аутентификации Google: %s", url)
	http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// handleCallback - обработчик для callback от Google
func handleCallback(w http.ResponseWriter, r *http.Request) {
	// Проверяем state для защиты от CSRF (здесь пропущено для простоты, но важно в продакшене)
	// state := r.URL.Query().Get("state")
	// if state != "state-token" {
	//     http.Error(w, "Invalid state token", http.StatusBadRequest)
	//     return
	// }

	code := r.URL.Query().Get("code")
	if code == "" {
		log.Println("Ошибка: Параметр 'code' отсутствует в callback запросе.")
		http.Error(w, "Code not found in request", http.StatusBadRequest)
		return
	}
	log.Printf("Получен код авторизации: %s", code)

	token, err := oauthConf.Exchange(context.Background(), code)
	if err != nil {
		log.Printf("Ошибка обмена кода на токен: %v", err)
		http.Error(w, fmt.Sprintf("Token exchange failed: %v", err), http.StatusInternalServerError)
		return
	}
	log.Printf("Токен получен успешно: AccessToken=%s...", token.AccessToken[:10]) // Логируем только часть токена

	client := oauthConf.Client(context.Background(), token)
	resp, err := client.Get("https://www.googleapis.com/oauth2/v3/userinfo")
	if err != nil {
		log.Printf("Ошибка получения информации о пользователе: %v", err)
		http.Error(w, fmt.Sprintf("Failed to get userinfo: %v", err), http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	var userinfo map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&userinfo); err != nil {
		log.Printf("Ошибка декодирования userinfo JSON: %v", err)
		http.Error(w, "Failed to decode userinfo", http.StatusInternalServerError)
		return
	}

	log.Printf("Информация о пользователе получена: %v", userinfo)
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(userinfo); err != nil {
		log.Printf("Ошибка отправки userinfo клиенту: %v", err)
		// Заголовок уже может быть отправлен, поэтому просто логируем
	}
}

// --- Main Function (Combined) ---

func main() {
	// --- Инициализация из main.txt ---
	rand.Seed(time.Now().UnixNano())

	hostnames := []string{
		"server-1", "server-2", "server-3", "server-4", "server-5",
	}

	// Запуск горутины рассылки метрик
	go handleMessages()
	log.Println("Горутина handleMessages запущена.")

	// Запуск горутин генерации метрик для каждого сервера
	for _, hostname := range hostnames {
		go generateMetricsForServer(hostname, broadcast)
		log.Printf("Горутина генерации метрик запущена для: %s", hostname)
	}

	// --- Регистрация обработчиков ---

	// WebSocket эндпоинт из main.txt
	http.HandleFunc("/ws", handleConnections)
	log.Println("WebSocket обработчик зарегистрирован на /ws")

	// OAuth эндпоинты из main1.txt
	http.HandleFunc("/auth", handleAuth)
	log.Println("Обработчик аутентификации зарегистрирован на /auth")
	http.HandleFunc("/callback", handleCallback)
	log.Println("Обработчик callback зарегистрирован на /callback")

	// --- Запуск сервера ---
	port := ":8080"
	log.Printf("Сервер запускается на порту %s", port)
	log.Printf("Доступные эндпоинты:")
	log.Printf("  - WebSocket метрики: ws://localhost%s/ws", port)
	log.Printf("  - Google Login:    http://localhost%s/auth", port)
	log.Printf("  - Google Callback: http://localhost%s/callback (используется Google)", port)

	err := http.ListenAndServe(port, nil)
	if err != nil {
		log.Fatal("Ошибка запуска сервера: ", err)
	}
}